## question
给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。

如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。

设计一个时间复杂度为 O(n logn) 或 O(n) 的解决方案。

## examples
输入：nums = [1,2,3,4]\
输出：false

输入：nums = [3,1,4,2]\
输出：true

输入：nums = [-1,3,2,0]\
输出：true

## notes
C++ \
std::multiset：是含有 Key 类型对象有序集的容器。不同于 set ，它允许多个关键拥有等价的值，自带排序。

lower_bound:\
功能：查找非递减序列[first,last) 内第一个大于或等于某个元素的位置。\
返回值：如果找到返回找到元素的地址否则返回last的地址。

upper_bound:\
功能：查找非递减序列[first,last) 内第一个大于某个元素的位置。\
返回值：如果找到返回找到元素的地址否则返回last的地址。

单调栈：在单调栈中，从栈底到栈顶的元素是严格单调递减的。当给定阈值x时，我们只需要不断地弹出栈顶的元素，直到栈为空或者x严格小于栈顶元素。此时我们再将x入栈，这样就维护了栈的单调性。
入栈，这样就维护了栈的单调性。




